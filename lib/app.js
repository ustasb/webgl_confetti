// Generated by CoffeeScript 1.4.0
(function() {
  var ANIMATE_OPACITY, RADIANS_PER_DEGREE, cameraPos, confettiEmitter, cubeIndexBuffer, cubeVertexBuffer, draw, drawCube, drawFloor, floorIndexBuffer, floorVertexBuffer, getShaderFromDOM, gl, init, initBuffers, initCubeBuffer, initFloorBuffer, initGLContext, initShaders, modelViewMatrix, modelViewMatrixStack, mouseDeltaX, prepareToDraw, projectionMatrix, sendModelViewMatrixToShader, sendProjectionMatrixToShader, shaderProgram;

  RADIANS_PER_DEGREE = Math.PI / 180;

  ANIMATE_OPACITY = false;

  gl = void 0;

  shaderProgram = void 0;

  mouseDeltaX = 0;

  cameraPos = {
    x: -5,
    y: 3,
    z: 5
  };

  floorVertexBuffer = void 0;

  floorIndexBuffer = void 0;

  cubeVertexBuffer = void 0;

  cubeIndexBuffer = void 0;

  confettiEmitter = new ConfettiEmitter(0, 0.8, 0);

  projectionMatrix = mat4.create();

  modelViewMatrix = mat4.create();

  modelViewMatrixStack = {
    stack: [],
    push: function() {
      return this.stack.push(mat4.clone(modelViewMatrix));
    },
    pop: function() {
      return modelViewMatrix = this.stack.pop();
    }
  };

  sendProjectionMatrixToShader = function() {
    return gl.uniformMatrix4fv(shaderProgram.projectionMatrixUniform, false, projectionMatrix);
  };

  sendModelViewMatrixToShader = function() {
    return gl.uniformMatrix4fv(shaderProgram.modelViewMatrixUniform, false, modelViewMatrix);
  };

  initGLContext = function() {
    var canvas;
    canvas = document.getElementById('gl-canvas');
    gl = canvas.getContext('experimental-webgl');
    gl.viewportWidth = canvas.width;
    return gl.viewportHeight = canvas.height;
  };

  getShaderFromDOM = function(id, shaderType) {
    var shader, source;
    source = $('#' + id).text();
    if (shaderType === 'vertex') {
      shader = gl.createShader(gl.VERTEX_SHADER);
    } else if (shaderType === 'fragment') {
      shader = gl.createShader(gl.FRAGMENT_SHADER);
    }
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
  };

  initShaders = function() {
    var fragmentShader, vertexShader;
    vertexShader = getShaderFromDOM('vertex-shader', 'vertex');
    fragmentShader = getShaderFromDOM('fragment-shader', 'fragment');
    shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    gl.useProgram(shaderProgram);
    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
    shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, 'aVertexColor');
    shaderProgram.projectionMatrixUniform = gl.getUniformLocation(shaderProgram, 'uProjectionMatrix');
    return shaderProgram.modelViewMatrixUniform = gl.getUniformLocation(shaderProgram, 'uModelViewMatrix');
  };

  initBuffers = function() {
    initFloorBuffer();
    return initCubeBuffer();
  };

  initFloorBuffer = function() {
    var floorIndices, floorVertices;
    floorVertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, floorVertexBuffer);
    floorVertices = [1, 0, -1, -1, 0, -1, -1, 0, 1, 1, 0, 1];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(floorVertices), gl.STATIC_DRAW);
    floorVertexBuffer.numOfItems = 4;
    floorVertexBuffer.itemSize = 3;
    floorIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, floorIndexBuffer);
    floorIndices = [0, 1, 2, 0, 3, 2];
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(floorIndices), gl.STATIC_DRAW);
    floorIndexBuffer.numOfItems = 6;
    return floorIndexBuffer.itemSize = 1;
  };

  drawFloor = function() {
    gl.disableVertexAttribArray(shaderProgram.vertexColorAttribute);
    gl.vertexAttrib4f(shaderProgram.vertexColorAttribute, 0, 0, 1, 1);
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
    gl.bindBuffer(gl.ARRAY_BUFFER, floorVertexBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, floorVertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, floorIndexBuffer);
    gl.drawElements(gl.TRIANGLE_FAN, floorIndexBuffer.numOfItems, gl.UNSIGNED_SHORT, 0);
    gl.lineWidth(2);
    gl.vertexAttrib4f(shaderProgram.vertexColorAttribute, 1, 1, 0, 1);
    return gl.drawElements(gl.LINE_LOOP, floorIndexBuffer.numOfItems, gl.UNSIGNED_SHORT, 0);
  };

  initCubeBuffer = function() {
    var cubeIndices, cubeVertices;
    cubeVertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexBuffer);
    cubeVertices = [1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeVertices), gl.STATIC_DRAW);
    cubeVertexBuffer.numOfItems = 24;
    cubeVertexBuffer.itemSize = 3;
    cubeIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIndexBuffer);
    cubeIndices = [0, 1, 2, 0, 2, 3, 4, 6, 5, 4, 7, 6, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 22, 21, 20, 23, 22];
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeIndices), gl.STATIC_DRAW);
    cubeIndexBuffer.numOfItems = 36;
    return cubeIndexBuffer.itemSize = 1;
  };

  drawCube = function() {
    gl.disableVertexAttribArray(shaderProgram.vertexColorAttribute);
    gl.vertexAttrib4f(shaderProgram.vertexColorAttribute, 1, 0, 0, 1);
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIndexBuffer);
    gl.drawElements(gl.TRIANGLES, cubeVertexBuffer.numOfItems, gl.UNSIGNED_SHORT, 0);
    gl.lineWidth(2);
    gl.vertexAttrib4f(shaderProgram.vertexColorAttribute, 1, 1, 0, 1);
    return gl.drawElements(gl.LINE_LOOP, cubeIndexBuffer.numOfItems, gl.UNSIGNED_SHORT, 0);
  };

  prepareToDraw = function() {
    var vertical_fov;
    vertical_fov = 60 * RADIANS_PER_DEGREE;
    mat4.perspective(projectionMatrix, vertical_fov, gl.viewportWidth / gl.viewportHeight, 0.1, 100);
    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(0, 0, 0, 1);
    return gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
  };

  draw = function() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    mat4.identity(modelViewMatrix);
    mat4.lookAt(modelViewMatrix, [cameraPos.x, cameraPos.y, cameraPos.z], [0, 0, 0], [0, 1, 0]);
    mat4.rotateY(modelViewMatrix, modelViewMatrix, (mouseDeltaX / 10) * RADIANS_PER_DEGREE);
    sendProjectionMatrixToShader();
    sendModelViewMatrixToShader();
    confettiEmitter.update();
    confettiEmitter.draw(ANIMATE_OPACITY);
    modelViewMatrixStack.push();
    mat4.scale(modelViewMatrix, modelViewMatrix, [2, 2, 2]);
    sendModelViewMatrixToShader();
    drawFloor();
    modelViewMatrixStack.pop();
    modelViewMatrixStack.push();
    mat4.scale(modelViewMatrix, modelViewMatrix, [0.3, 0.3, 0.3]);
    mat4.translate(modelViewMatrix, modelViewMatrix, [0, 1.03, 0]);
    sendModelViewMatrixToShader();
    drawCube();
    mat4.scale(modelViewMatrix, modelViewMatrix, [0.5, 0.5, 0.5]);
    mat4.translate(modelViewMatrix, modelViewMatrix, [0, 3, 0]);
    sendModelViewMatrixToShader();
    drawCube();
    modelViewMatrixStack.pop();
    return setTimeout(draw, 30);
  };

  init = function() {
    initGLContext();
    initShaders();
    initBuffers();
    window.gl = gl;
    window.shaderProgram = shaderProgram;
    prepareToDraw();
    return draw();
  };

  $(function() {
    var $confettiCount, mouseDown, oldMouseDeltaX, onStop;
    init();
    mouseDown = false;
    oldMouseDeltaX = 0;
    onStop = function() {
      mouseDown = false;
      return oldMouseDeltaX = mouseDeltaX;
    };
    $('#gl-canvas').mousedown(function(e) {
      return mouseDown = {
        x: e.pageX,
        y: e.pageY
      };
    }).mouseup(onStop).mouseout(onStop).mousemove(function(e) {
      if (mouseDown) {
        return mouseDeltaX = oldMouseDeltaX + e.pageX - mouseDown.x;
      }
    });
    $confettiCount = $('#confetti-count');
    $confettiCount.text(ConfettiEmitter.maxAliveConfetti);
    $('#confetti-slider').slider({
      value: ConfettiEmitter.maxAliveConfetti,
      min: 10,
      max: 10000,
      slide: function(e, ui) {
        ConfettiEmitter.maxAliveConfetti = ui.value;
        return $confettiCount.text(ui.value);
      }
    });
    return $('#animate-opacity').change(function() {
      return ANIMATE_OPACITY = this.checked;
    });
  });

}).call(this);
